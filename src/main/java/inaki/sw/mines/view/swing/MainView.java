package inaki.sw.mines.view.swing;

import inaki.sw.mines.controller.Controller;
import inaki.sw.mines.model.Board;
import inaki.sw.mines.view.MainViewInterface;
import static java.awt.Color.black;
import static java.awt.Color.decode;
import static java.awt.Color.red;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import static java.awt.event.KeyEvent.VK_C;
import static java.awt.event.KeyEvent.VK_E;
import static java.awt.event.KeyEvent.VK_L;
import static java.awt.event.KeyEvent.VK_N;
import static java.awt.event.KeyEvent.VK_O;
import static java.awt.event.KeyEvent.VK_R;
import static java.awt.event.KeyEvent.VK_S;
import static java.awt.event.KeyEvent.VK_V;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import static java.awt.event.MouseEvent.BUTTON1;
import static java.awt.event.MouseEvent.BUTTON3;
import static java.lang.Integer.parseInt;
import static java.lang.Math.max;
import static java.lang.Math.min;
import java.util.HashMap;
import java.util.Map;
import static java.util.concurrent.ThreadLocalRandom.current;
import static java.util.logging.Level.SEVERE;
import static java.util.logging.Logger.getLogger;
import javax.swing.JButton;
import javax.swing.JFrame;
import static javax.swing.SwingUtilities.updateComponentTreeUI;
import static javax.swing.UIManager.setLookAndFeel;
import javax.swing.UnsupportedLookAndFeelException;

/**
 *
 * @author inaki
 */
public class MainView extends JFrame implements MainViewInterface {

    private Board b;
    private JButton[][] jbBoardButtons;
    private int trucoSOLVE = 0;
    private int primaryClikNumber = 0;
    private int secondaryClikNumber = 0;
    private Controller c;

    /**
     * Creates new form MainView
     */
    public MainView() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jpmClue = new javax.swing.JPopupMenu();
        jmiClue1 = new javax.swing.JMenuItem();
        jmiClue2 = new javax.swing.JMenuItem();
        jmiClue3 = new javax.swing.JMenuItem();
        jtbTop = new javax.swing.JToolBar();
        jbNew = new javax.swing.JButton();
        jbRestart = new javax.swing.JButton();
        jbClue = new javax.swing.JButton();
        jlChrono = new javax.swing.JLabel();
        jpMain = new javax.swing.JPanel();
        jpBottom = new javax.swing.JPanel();
        jlFlag1 = new javax.swing.JLabel();
        jlFlag2 = new javax.swing.JLabel();
        jlFlag3 = new javax.swing.JLabel();
        jlFlag4 = new javax.swing.JLabel();
        jlDiscovered1 = new javax.swing.JLabel();
        jlDiscovered2 = new javax.swing.JLabel();

        jmiClue1.setText("Clue 1: White area");
        jmiClue1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiClue1ActionPerformed(evt);
            }
        });
        jpmClue.add(jmiClue1);

        jmiClue2.setText("Clue 2: A number");
        jmiClue2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiClue2ActionPerformed(evt);
            }
        });
        jpmClue.add(jmiClue2);

        jmiClue3.setText("Clue 3: A flag");
        jmiClue3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiClue3ActionPerformed(evt);
            }
        });
        jpmClue.add(jmiClue3);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("I-SW Mines");
        setIconImage(new javax.swing.ImageIcon(getClass().getResource("/icon/isw-mines-96.png")).getImage());
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                formKeyTyped(evt);
            }
        });

        jtbTop.setFloatable(false);
        jtbTop.setRollover(true);

        jbNew.setText("<html>\n<body>\n<h3>New</h3>\n</body>\n</html>");
        jbNew.setFocusable(false);
        jbNew.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jbNew.setMargin(new java.awt.Insets(0, 10, 0, 10));
        jbNew.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jtbTop.add(jbNew);

        jbRestart.setText("<html>\n<body>\n<h3>Restart</h3>\n</body>\n</html>");
        jbRestart.setFocusable(false);
        jbRestart.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jbRestart.setMargin(new java.awt.Insets(0, 10, 0, 10));
        jbRestart.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jtbTop.add(jbRestart);

        jbClue.setText("<html> <body> <h3>Clue</h3> </body> </html>");
        jbClue.setComponentPopupMenu(jpmClue);
        jbClue.setFocusable(false);
        jbClue.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jbClue.setMargin(new java.awt.Insets(0, 10, 0, 10));
        jbClue.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jbClue.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbClueActionPerformed(evt);
            }
        });
        jtbTop.add(jbClue);

        jlChrono.setText("<html> <body> <h3>00:00</h3> </body> </html>");
        jtbTop.add(jlChrono);

        javax.swing.GroupLayout jpMainLayout = new javax.swing.GroupLayout(jpMain);
        jpMain.setLayout(jpMainLayout);
        jpMainLayout.setHorizontalGroup(
            jpMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jpMainLayout.setVerticalGroup(
            jpMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 59, Short.MAX_VALUE)
        );

        jlFlag1.setText("Flags:");

        jlFlag2.setText("0");

        jlFlag3.setText("/");

        jlFlag4.setText("0");

        jlDiscovered1.setText("Discovered:");

        jlDiscovered2.setText("0%");

        javax.swing.GroupLayout jpBottomLayout = new javax.swing.GroupLayout(jpBottom);
        jpBottom.setLayout(jpBottomLayout);
        jpBottomLayout.setHorizontalGroup(
            jpBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpBottomLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jlFlag1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jlFlag2)
                .addGap(0, 0, 0)
                .addComponent(jlFlag3)
                .addGap(0, 0, 0)
                .addComponent(jlFlag4)
                .addGap(18, 18, 18)
                .addComponent(jlDiscovered1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jlDiscovered2)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jpBottomLayout.setVerticalGroup(
            jpBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jpBottomLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jpBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jlFlag1)
                    .addComponent(jlFlag2)
                    .addComponent(jlFlag3)
                    .addComponent(jlFlag4)
                    .addComponent(jlDiscovered1)
                    .addComponent(jlDiscovered2))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jtbTop, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jpMain, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jpBottom, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jtbTop, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jpMain, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jpBottom, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyTyped
        switch (evt.getKeyChar()) {
            case VK_C:
                trucoSOLVE = 0;
                jbClue.doClick();
                break;
            case VK_E:
                if (trucoSOLVE == 4) {
                    c.actionPerformed(new ActionEvent(this, 0, MV_SOLVE));
                }
                trucoSOLVE = 0;
                break;
            case VK_L:
                trucoSOLVE = (trucoSOLVE == 2) ? 3 : 0;
                break;
            case VK_N:
                trucoSOLVE = 0;
                jbNew.doClick();
                break;
            case VK_O:
                trucoSOLVE = (trucoSOLVE == 1) ? 2 : 0;
                break;
            case VK_R:
                trucoSOLVE = 0;
                jbRestart.doClick();
                break;
            case VK_S:
                trucoSOLVE = 1;
                break;
            case VK_V:
                trucoSOLVE = (trucoSOLVE == 3) ? 4 : 0;
                break;
            default:
                trucoSOLVE = 0;
                break;
        }
    }//GEN-LAST:event_formKeyTyped

    private void jbClueActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbClueActionPerformed
        jpmClue.show(jbClue, jbClue.getSize().width, 0);
    }//GEN-LAST:event_jbClueActionPerformed

    private void jmiClue1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiClue1ActionPerformed
        showClue(1);
        jmiClue1.setEnabled(false);
    }//GEN-LAST:event_jmiClue1ActionPerformed

    private void jmiClue2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiClue2ActionPerformed
        showClue(2);
        jmiClue2.setEnabled(false);
    }//GEN-LAST:event_jmiClue2ActionPerformed

    private void jmiClue3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiClue3ActionPerformed
        showClue(3);
        jmiClue3.setEnabled(false);
    }//GEN-LAST:event_jmiClue3ActionPerformed

    private void jbActionPerformed(ActionEvent evt) {
        String[] s = evt.getActionCommand().split("x");
        int _m = parseInt(s[0]);
        int _n = parseInt(s[1]);
        uncover(_m, _n);
    }

    private void jbMouseReleased(MouseEvent evt) {
        String[] s = ((JButton) evt.getComponent()).getActionCommand().split("x");
        int _m = parseInt(s[0]);
        int _n = parseInt(s[1]);
        if (evt.getButton() == BUTTON1) {
            /* Uncover the surrounding, only if current is uncovered, has a
            * number and on the surrounding are marked exactly the number of
            * cells that current's number indicates */
            primaryClikNumber += 1;
            uncoverSurrounding(_m, _n);
        } else if (evt.getButton() == BUTTON3) {
            /* Mark a cell */
            secondaryClikNumber += 1;
            mark(_m, _n);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jbClue;
    private javax.swing.JButton jbNew;
    private javax.swing.JButton jbRestart;
    private javax.swing.JLabel jlChrono;
    private javax.swing.JLabel jlDiscovered1;
    private javax.swing.JLabel jlDiscovered2;
    private javax.swing.JLabel jlFlag1;
    private javax.swing.JLabel jlFlag2;
    private javax.swing.JLabel jlFlag3;
    private javax.swing.JLabel jlFlag4;
    private javax.swing.JMenuItem jmiClue1;
    private javax.swing.JMenuItem jmiClue2;
    private javax.swing.JMenuItem jmiClue3;
    private javax.swing.JPanel jpBottom;
    private javax.swing.JPanel jpMain;
    private javax.swing.JPopupMenu jpmClue;
    private javax.swing.JToolBar jtbTop;
    // End of variables declaration//GEN-END:variables
    /**
     *
     * @param c
     */
    @Override
    public void setController(Controller c) {
        this.c = c;
        jbNew.addActionListener(this.c);
        jbNew.setActionCommand(MV_NEW);
        jbRestart.addActionListener(this.c);
        jbRestart.setActionCommand(MV_RESTART);
    }

    @Override
    public void startView() {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code">
        try {
            setLookAndFeel("javax.swing.plaf.nimbus.NimbusLookAndFeel");
            updateComponentTreeUI(this);
            this.repaint();
        }
        catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            getLogger(MainView.class.getName()).log(SEVERE, null, ex);
        }
        finally {
            this.pack();
        }
        //</editor-fold>
        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setLocationRelativeTo(null);
        updateChronometer(0, 0);
        this.primaryClikNumber = 0;
        this.secondaryClikNumber = 0;
        this.setVisible(true);
    }

    @Override
    public void hideView() {
    }

    @Override
    public int getHorizontal() {
        return b.getWidth();
    }

    @Override
    public int getVertical() {
        return b.getHeight();
    }

    @Override
    public int getMines() {
        return b.getMines();
    }

    @Override
    public int getPrimaryClikNumber() {
        return primaryClikNumber;
    }

    @Override
    public int getSecondaryClikNumber() {
        return secondaryClikNumber;
    }

    @Override
    public int getDiscoveredPrecentage() {
        return Integer.parseInt(jlDiscovered2.getText().substring(0, jlDiscovered2.getText().length() - 1));
    }

    @Override
    public void setBoard(final Board b) {
        this.b = b;
        jpMain.removeAll();
        jpMain.setLayout(new GridLayout(b.getHeight(), b.getWidth()));
        initializeButtons();
        for (int i = 0; i < b.getHeight(); i++) {
            for (int j = 0; j < b.getWidth(); j++) {
                jpMain.add(jbBoardButtons[i][j]);
            }
        }
        jlFlag2.setText("0");
        jlFlag4.setText(b.getMines() + "");
        jlDiscovered2.setText(0 + "%");
        jbClue.setEnabled(true);
        jmiClue1.setEnabled(true);
        jmiClue2.setEnabled(true);
        jmiClue3.setEnabled(true);
        this.pack();
    }

    @Override
    public void solveBoard() {
        jbClue.setEnabled(false);
        jmiClue1.setEnabled(false);
        jmiClue2.setEnabled(false);
        jmiClue3.setEnabled(false);
        for (int i = 0; i < b.getHeight(); i++) {
            for (int j = 0; j < b.getWidth(); j++) {
                if (b.getBoard(i, j) != -1) {
                    uncover(i, j);
                } else {
                    jbBoardButtons[i][j].setText(":)");
                }
            }
        }
        jlFlag2.setText(jlFlag4.getText());
    }

    @Override
    public void updateChronometer(int m, int s) {
        String pre = "<html><body><h3>";
        String time = (m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s;
        String post = "</h3></body></html>";
        jlChrono.setText(pre + time + post);
    }

    private void initializeButtons() {
        final Dimension d = new Dimension(40, 35);
        jbBoardButtons = new JButton[b.getHeight()][b.getWidth()];
        for (int i = 0; i < b.getHeight(); i++) {
            for (int j = 0; j < b.getWidth(); j++) {
                jbBoardButtons[i][j] = new JButton(" ");
                jbBoardButtons[i][j].setFocusable(false);
                jbBoardButtons[i][j].addActionListener(this::jbActionPerformed);
                jbBoardButtons[i][j].setActionCommand(i + "x" + j);
                jbBoardButtons[i][j].addMouseListener(new MouseAdapter() {
                    @Override
                    public void mouseReleased(MouseEvent evt) {
                        jbMouseReleased(evt);
                    }
                });
                jbBoardButtons[i][j].setPreferredSize(d);
                jbBoardButtons[i][j].setMaximumSize(d);
                jbBoardButtons[i][j].setMinimumSize(d);
                jbBoardButtons[i][j].setFont(new Font("Arial", 1, 11));
            }
        }
    }

    private int countDiscoveredCells() {
        int discovered = 0;
        for (int i = 0; i < b.getHeight(); i++) {
            for (int j = 0; j < b.getWidth(); j++) {
                if (!jbBoardButtons[i][j].isEnabled()) {
                    discovered++;
                }
            }
        }
        return discovered;
    }

    private void uncover(final int _m, final int _n) {
        if (!jbBoardButtons[_m][_n].getText().equals(":)") && jbBoardButtons[_m][_n].isEnabled()) {
            jbBoardButtons[_m][_n].setEnabled(false);
            int discovered = countDiscoveredCells();
            if (discovered == 1) {
                c.actionPerformed(new ActionEvent(this, 0, MV_START_CHRONO));
            }
            if (discovered == b.getHeight() * b.getWidth() - b.getMines()) {
                c.actionPerformed(new ActionEvent(this, 0, MV_WIN));
            }
            final float p = (float) discovered / (float) (b.getHeight() * b.getWidth() - b.getMines()) * 100f;
            jlDiscovered2.setText((int) p + "%");
            switch (b.getBoard(_m, _n)) {
                case -1:
                    for (int i = 0; i < b.getHeight(); i++) {
                        for (int j = 0; j < b.getWidth(); j++) {
                            if (b.getBoard(i, j) == -1) {
                                jbBoardButtons[i][j].setText(":(");
                                jbBoardButtons[i][j].setForeground(decode("#000000"));
                            }
                            if (jbBoardButtons[i][j].getText().equals(":)")) {
                                jbBoardButtons[i][j].setText("X");
                                jbBoardButtons[i][j].setForeground(decode("#FF6600"));
                            }
                            jbBoardButtons[i][j].setEnabled(false);
                        }
                    }
                    jbClue.setEnabled(false);
                    jmiClue1.setEnabled(false);
                    jmiClue2.setEnabled(false);
                    jmiClue3.setEnabled(false);
                    c.actionPerformed(new ActionEvent(this, 0, MV_LOST));
                    break;
                case 0:
                    final int m1 = max(0, _m - 1);
                    final int m2 = min(b.getHeight() - 1, _m + 1);
                    final int n1 = max(0, _n - 1);
                    final int n2 = min(b.getWidth() - 1, _n + 1);
                    for (int _i = m1; _i <= m2; _i++) {
                        for (int _j = n1; _j <= n2; _j++) {
                            if (jbBoardButtons[_i][_j].isEnabled()) {
                                uncover(_i, _j);
                            }
                        }
                    }
                    break;
                case 1:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#2222FF"));
                    break;
                case 2:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#008800"));
                    break;
                case 3:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#FF0000"));
                    break;
                case 4:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#000088"));
                    break;
                case 5:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#800000"));
                    break;
                case 6:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#0099CC"));
                    break;
                case 7:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#990099"));
                    break;
                case 8:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    jbBoardButtons[_m][_n].setForeground(decode("#CC9900"));
                    break;
                default:
                    jbBoardButtons[_m][_n].setText(b.getBoard(_m, _n) + "");
                    break;
            }
        }
    }

    private void mark(final int _m, final int _n) {
        if (jbBoardButtons[_m][_n].isEnabled()) {
            /* Comprobamos si esta etiquetada o no */
            if (jbBoardButtons[_m][_n].getText().equals(":)")) {
                // Si lo esta, la desetiquetamos
                jbBoardButtons[_m][_n].setText(" ");
                jlFlag2.setText((parseInt(jlFlag2.getText()) - 1) + "");
            } else {
                // Si no, la etiquetamos
                jbBoardButtons[_m][_n].setText(":)");
                jlFlag2.setText((parseInt(jlFlag2.getText()) + 1) + "");
            }
            /* Comprobamos si hemos puesto demasiadas banderas en el tablero */
            if (parseInt(jlFlag2.getText()) > parseInt(jlFlag4.getText())) {
                jlFlag1.setForeground(red);
                jlFlag2.setForeground(red);
                jlFlag3.setForeground(red);
                jlFlag4.setForeground(red);
            } else {
                jlFlag1.setForeground(black);
                jlFlag2.setForeground(black);
                jlFlag3.setForeground(black);
                jlFlag4.setForeground(black);
            }
        }
    }

    private void uncoverSurrounding(final int _m, final int _n) {
        if (!jbBoardButtons[_m][_n].isEnabled()) {
            final int number = b.getBoard(_m, _n);
            if (number > 0) {
                final int m1 = max(0, _m - 1);
                final int m2 = min(b.getHeight() - 1, _m + 1);
                final int n1 = max(0, _n - 1);
                final int n2 = min(b.getWidth() - 1, _n + 1);
                /* Check how many cells are marked surround it */
                int marked = 0;
                for (int _i = m1; _i <= m2; _i++) {
                    for (int _j = n1; _j <= n2; _j++) {
                        if (jbBoardButtons[_i][_j].getText().equals(":)")) {
                            marked++;
                        }
                    }
                }
                /* If are marked the same number as current cell's number,
                * we uncover the surrounding */
                if (number == marked) {
                    for (int _i = m1; _i <= m2; _i++) {
                        for (int _j = n1; _j <= n2; _j++) {
                            if (jbBoardButtons[_i][_j].isEnabled()) {
                                uncover(_i, _j);
                            }
                        }
                    }
                }
            }
        }
    }

    private void showClue(final int clue) {
        switch (clue) {
            case 1:
                showClue1();
                break;
            case 2:
                showClue2();
                break;
            case 3:
                showClue3();
                break;
        }
    }

    private void showClue1() {
        final Map<Integer, JButton> hm = new HashMap();
        for (int i = 0; i < b.getHeight(); i++) {
            for (int j = 0; j < b.getWidth(); j++) {
                if (jbBoardButtons[i][j].isEnabled() && b.getBoard(i, j) == 0) {
                    hm.put(hm.size(), jbBoardButtons[i][j]);
                }
            }
        }
        if (!hm.isEmpty()) {
            hm.get(current().nextInt(0, hm.size())).doClick();
        }
    }

    private void showClue2() {
        final Map<Integer, JButton> hm = new HashMap();
        for (int i = 0; i < b.getHeight(); i++) {
            for (int j = 0; j < b.getWidth(); j++) {
                if (jbBoardButtons[i][j].isEnabled() && b.getBoard(i, j) > 0) {
                    hm.put(hm.size(), jbBoardButtons[i][j]);
                }
            }
        }
        if (!hm.isEmpty()) {
            hm.get(current().nextInt(0, hm.size())).doClick();
        }
    }

    private void showClue3() {
        final Map<Integer, JButton> hm = new HashMap();
        for (int i = 0; i < b.getHeight(); i++) {
            for (int j = 0; j < b.getWidth(); j++) {
                if (jbBoardButtons[i][j].isEnabled() && b.getBoard(i, j) == -1 && !jbBoardButtons[i][j].getText().equals(":)")) {
                    hm.put(hm.size(), jbBoardButtons[i][j]);
                }
            }
        }
        if (!hm.isEmpty()) {
            String[] s = hm.get(current().nextInt(0, hm.size())).getActionCommand().split("x");
            final int _m = parseInt(s[0]);
            final int _n = parseInt(s[1]);
            mark(_m, _n);
        }
    }

}
